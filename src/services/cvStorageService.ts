import { supabase } from '../lib/supabase';
import { CVBuilderData } from '../types/cvBuilder';

export interface StoredCV {
  id: string;
  user_id?: string | null;
  session_id?: string | null;
  cv_data: CVBuilderData;
  job_data?: any;
  editor_data?: any;
  insights?: any[];
  is_paid: boolean;
  source?: string;
  status?: string;
  error_message?: string | null;
  created_at?: string;
  updated_at?: string;
  download_unlocked?: boolean;
  pdf_url?: string | null;
  file_name?: string | null;
  ats_json?: any;
  vision_text?: string | null;
  processed_at?: string | null;
}

export const cvStorageService = {
  /**
   * Save CV to the cvs table (primary table)
   */
  async saveCV(
    id: string | undefined,
    cvData: CVBuilderData
  ): Promise<{ success: boolean; id: string; error?: string }> {
    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();

      const { data, error } = await supabase
        .from('stored_cvs')
        .upsert(
          {
            id: id || undefined,
            user_id: user?.id || null,
            cv_data: cvData,
            status: 'draft',
            updated_at: new Date().toISOString(),
          },
          { onConflict: 'id' }
        )
        .select('id')
        .single();

      if (error) {
        console.error('saveCV error', error);
        return { success: false, id: '', error: error.message };
      }

      return { success: true, id: data.id };
    } catch (err: any) {
      console.error('saveCV exception', err);
      return { success: false, id: '', error: err.message };
    }
  },

  /**
   * Save full CV data including job data, editor data, and insights
   *
   * Make Integration:
   * - mode='processing': Creates record with status='processing' (before Make)
   * - mode='completed': Updates with status='completed' (after Make)
   * - editor_data and insights are only filled by Make or on completion
   *
   * CRITICAL: Always returns the cvId from Supabase (either provided or generated)
   */
  async saveCVData(params: {
    id?: string;
    cvData: CVBuilderData;
    jobData?: any;
    editorData?: any;
    insights?: any[];
    isPaid?: boolean;
    mode?: string;
    source?: string;
    sessionId?: string;
  }): Promise<{ success: boolean; cvId?: string; error?: string }> {
    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();

      console.log('üíæ [CV-STORAGE] Saving CV data to Supabase:', {
        id: params.id || 'will be generated by Supabase',
        mode: params.mode,
        source: params.source,
        hasJobData: !!params.jobData,
        hasEditorData: !!params.editorData,
        hasInsights: !!params.insights,
      });

      // Determine status based on mode
      let status = 'draft';
      if (params.mode === 'processing') {
        status = 'processing';
      } else if (params.mode === 'completed') {
        status = 'completed';
      }

      const upsertData: any = {
        user_id: user?.id || null,
        session_id: params.sessionId || null,
        cv_data: params.cvData,
        job_data: params.jobData || {},
        is_paid: params.isPaid ?? false,
        source: params.source || 'wizard',
        status,
        updated_at: new Date().toISOString(),
      };

      // Only include id if provided (otherwise Supabase generates it)
      if (params.id) {
        upsertData.id = params.id;
      }

      // Only set editor_data and insights if provided (Make fills these)
      if (params.insights !== undefined) {
        upsertData.insights = params.insights;
      }

      const { data, error } = await supabase
        .from('stored_cvs')
        .upsert(upsertData, { onConflict: 'id' })
        .select('id')
        .single();

      if (error) {
        console.error('‚ùå [CV-STORAGE] Save error:', error);
        return { success: false, error: error.message };
      }

      if (!data) {
        console.error('‚ùå [CV-STORAGE] No data returned from upsert');
        return { success: false, error: 'No data returned from database' };
      }

      const cvId = data.id;
      console.log('‚úÖ [CV-STORAGE] CV data saved successfully:', { cvId, status });
      return { success: true, cvId };
    } catch (err: any) {
      console.error('‚ùå [CV-STORAGE] Save exception:', err);
      return { success: false, error: err.message };
    }
  },

  /**
   * Load CV data by ID
   */
  async loadCVData(id: string): Promise<{ success: boolean; data?: StoredCV; error?: string }> {
    try {
      const { data, error } = await supabase
        .from('stored_cvs')
        .select('*')
        .eq('id', id)
        .maybeSingle();

      if (error) {
        console.error('‚ùå [CV-STORAGE] Load error:', error);
        return { success: false, error: error.message };
      }

      if (!data) {
        return { success: false, error: 'CV not found' };
      }

      return { success: true, data: data as StoredCV };
    } catch (err: any) {
      console.error('‚ùå [CV-STORAGE] Load exception:', err);
      return { success: false, error: err.message };
    }
  },

  /**
   * Get all CVs for a specific user
   */
  async getUserCVs(userId: string): Promise<{ success: boolean; data?: StoredCV[]; error?: string }> {
    try {
      const { data, error } = await supabase
        .from('stored_cvs')
        .select('id, user_id, cv_data, job_data, status, source, pdf_url, download_unlocked, updated_at, created_at')
        .eq('user_id', userId)
        .order('updated_at', { ascending: false });

      if (error) {
        console.error('‚ùå [CV-STORAGE] Get user CVs error:', error);
        return { success: false, error: error.message };
      }

      return { success: true, data: (data || []) as StoredCV[] };
    } catch (err: any) {
      console.error('‚ùå [CV-STORAGE] Get user CVs exception:', err);
      return { success: false, error: err.message };
    }
  },
};
